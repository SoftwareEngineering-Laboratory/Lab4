# داک پروژه

در این قسمت به مستندات پروژه می‌پردازیم.

### استفاده از الگوی facade

۱. ابتدا این الگو را برای codeGenerator استفاده کردیم. به طوری که تمامی پکیج‌های دیگر برای استفاده از این پکیج باید از طریق کلاس CodeGeneratorFacade اقدام به دسترسی کنند. در تمامی پکیج‌های دیگر فقط CodeGeneratorFacade را import کرده‌ایم مگر وقتی که می‌خواستیم از تایپ یکی از کلاس‌های این پکیج استفاده کنیم. منظور از این نوع استفاده نیز فقط مشخص کردن تایپ متغیر‌های استفاده شده در پکیج‌های دیگر است.


۲. جای دیگری که از این الگو استفاده کردیم برای پکیج scanner است. به طوری که تمامی پکیج‌های دیگر از این پس تنها کلاس ScannerFacade را import کرده‌اند. فقط در برخی جاها که نیاز به کلاس Token برای تایپینگ می‌بود، این کلاس در پکیج‌های مربوطه import شده است.

### استفاده از الگوی strategy

برای متغیر action در کلاس Action پکیج parser این الگو را استفاده کردیم. در دو جا روی این متغیر سوییچ کیس زده شده بود که این دو را با استفاده از این الگو از بین بردیم و از طریق متد کال آن را ریفکتور کردیم. کلاس‌ها و توابع پیاده‌سازی شده را می‌توانید در پکیج acts در ذیل پکیج parser مشاهده کنید.


### اعمال  Separate Query from Modifier

برای تابع getTemp در کلاس Memory ذیل پکیج codeGenerator که دو کار افزایش متغیر و برگرداندن متغیر را انجام می‌داد، یک تابع دیگر به نام incTemp نوشتیم و این دو کار را از یکدیگر جدا کردیم. در مرحله بعد، هرجا که از getTemp استفاده شده بود را تغییر دادیم و قبل آن تابع incTemp را صدا زدیم.

### اعمال Self Encapsulate Field

برای کلاس CodeGenerator ذیل پکیج codeGenerator این فرآیند را اعمال کردیم و آن دسته از متغیر‌های پرایوت کلاس را که نیاز به setter یا getter داشتند، برایشان توابع ذکر شده مناسب را نوشتیم.


### اعمال Inline Temp

در تابع hashCode کلاس Token و تابع get کلاس SymbolTable این ریفکتورینگ را اعمال کردیم و متغیر‌های temp را حذف کردیم.

### اعمال Substitute Algorithm

در کلاس Address برای تابع toString با استفاده از HashMap آن را بازنویسی کردیم و سوییچ کیس را از آن حذف کردیم.

در کلاس Symbol نیز با استفاده از HashMap روی type کلاس Symbol از استفاده از سوییچ کیس در قسمت‌های مختلف کد روی این تایپ پرهیز کردیم.

---
## پرسش‌ها
### ۱. هر یک از مفاهیم زیر را در حد یک خط توضیح دهید.

- **کد تمیز**

کد تمیز: نوشتاری که سازماندهی دقیقی دارد، روان و قابل درک است، شامل نامگذاری مناسب، ساختار واضح، کامنت‌گذاری خوب، تفکیک وظایف، استفاده از الگوهای طراحی، جلوگیری از تکرار، تست‌های واحد و انتگراسیون، مدیریت خطا و عدم استفاده از مقادیر ثابت بدون توضیح.

- **بدهی فنی**

بدهی فنی به مشکلات نرم‌افزار ناشی از تصمیمات فنی نادرست در گذشته اشاره دارد که می‌تواند باعث تاخیرها، خطاها، کاهش کیفیت و کاهش سرعت توسعه شود.

- **بوی بد**

به مشکلاتی که به دلیل طراحی نادرست یا ساختار پیچیده، کد را دشوار قابلیت توسعه و نگهداری می‌کند. این اشکالات ممکن است منجر به کاهش کیفیت، افزایش خطاها و هزینه‌ها شود.

### ۲.  بوهای بد کد به پنج دسته تقسیم می‌شوند. در مورد هر کدام از این پنج دسته توضیح مختصری دهید.

- **Duplicated Code**

وقوع تکرارهای ناپسند از بخش‌های کد مختلف که باعث کاهش خواندنیت و سختی تغییرات می‌شود.


- **Long Method**

نوشتن توابع یا متدهای بسیار طولانی و پیچیده که باعث کاهش فهم و نگهداری کد می‌شود.

- **Bad Naming**

استفاده از نام‌های نامناسب برای متغیرها، توابع یا کلاس‌ها که باعث ابهام و سردرگمی درک کد می‌شود.

- **Vertical Separation**

تداخل نامناسب بین بخش‌های مرتبط از کد که می‌تواند منجر به کاهش قابلیت تغییر و پیچیدگی شود.

- **Inappropriate Coupling**

وابستگی زیاد و ناخواسته بین ماژول‌ها یا کلاس‌ها که باعث کاهش انعطاف‌پذیری و تست‌پذیری می‌شود.


### ۳. یکی از انواع بوهای بد، Lazy Class است. 

#### ۳.۱ این بوی بد در کدام یک از دسته‌بندی‌های پنج‌گانه قرار می‌گیرد؟ 
تناپسندی (Long Method)

#### ۳.۲ برای برطرف‌کردن این بو، استفاده از کدام بازآرایی‌ها پیشنهاد می‌شود؟ 
برای رفع بوی بد "Lazy Class" در کد، می‌توانید از تجزیه توابع، حذف توابع بی‌ارزش، تجزیه کلاس‌ها، استفاده از توابع پیش‌ساخته و تجزیه و تحلیل دقیق برای بهبود کد استفاده کنید.

#### ۳.۳ در چه مواقعی باید این بو را نادیده گرفت؟
بوی بد "Lazy Class" ممکن است در مواردی که کلاس یا تابع‌های مرتبط به آن در آینده کاربرد دارند، به تغییرات آتی نیاز است یا در نقاطی که بهره‌وری و کارایی مهم هستند، نادیده گرفته شود. در صورتی که کد به صورت تجربی نوشته شده باشد و بهبود بیشتری نداشته باشد، نیز ممکن است در نظر گرفته شود.